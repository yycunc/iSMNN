% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/iSMNN.R
\name{iSMNN}
\alias{iSMNN}
\title{iSMNN}
\usage{
iSMNN(object.list = merge.list, batch.cluster.labels = batch.cluster.labels, matched.clusters = c("Endothelial cells", "Macrophage", "Fibroblast"), strategy = "Short.run", iterations = 5, dims = 1:20, npcs = 30)
}
\arguments{
\item{object.list}{A list of \code{\link{Seurat}} objects between which to find anchors for downstream integration.}

\item{assay}{A vector of assay names specifying which assay to use when constructing anchors. If NULL, the current default assay for each object is used.}

\item{batch.cluster.labels}{is a list of vectors specifying the cluster labels of each cell from each batch. Cells not belonging to any clusters should be set to 0.}

\item{matched.clusters}{specifies the cell clusters matched between two or more batches.}

\item{strategy}{XXX}

\item{iterations}{defines the number of iterations to execute.}

\item{reference}{A vector specifying the object/s to be used as a reference during integration. If NULL (default),
all pairwise anchors are found (no reference/s). If not NULL, the corresponding objects in \code{object.list}
will be used as references. When using a set of specified references, anchors are first found between each query and each reference
The references are then integrated through pairwise integration. Each query is then mapped to the integrated reference}

\item{anchor.features}{Can be either:
\itemize{
  \item{A numeric value. This will call \code{\link{SelectIntegrationFeatures}} to select the provided number of features to be used in anchor finding}
  \item{A vector of features to be used as input to the anchor finding process}
}}

\item{scale}{Whether or not to scale the features provided. Only set to FALSE
if you have previously scaled the features you want to use for each object in
the object.list}

\item{reduction}{Dimensional reduction to perform when finding anchors. Can
be one of:
\itemize{
  \item{cca: Canonical correlation analysis}
  \item{rpca: Reciprocal PCA}
}}

\item{l2.norm}{Perform L2 normalization on the CCA cell embeddings after dimensional reduction}

\item{dims}{Which dimensions to use from the CCA to specify the neighbor search space}

\item{k.anchor}{How many neighbors (k) to use when picking anchors}

\item{k.filter}{How many neighbors (k) to use when filtering anchors}

\item{k.score}{How many neighbors (k) to use when scoring anchors}

\item{max.features}{The maximum number of features to use when specifying the neighborhood search space in the anchor filtering}

\item{nn.method}{Method for nearest neighbor finding. Options include: rann, annoy}

\item{eps}{Error bound on the neighbor finding algorithm (from RANN)}

\item{k.weight}{Number of neighbors to consider when weighting. Default is \code{k.weight = 100}}

\item{verbose}{Print progress bars and output}

\item{sd.weigth}{defines the bandwidth of the Gaussian smoothing kernel used to compute the correction vector for each cell. Default is \code{sd.weigth = 1}}
}
\value{
iSMNN returns a Seurat object that contains the the batch-corrected expression matrix for batches
}
\description{
This function iSMNN is designed to perform iterative supervised batch effect correction for scRNA-seq data by refining mutual nearest neighbors (MNNs) within corresponding clusters (or cell types) on the top of corrected data.
It takes as input raw expression matrices from two or more batches and a list of the unified cluster labels (output from unifiedClusterLabelling of SMNN package).
It outputs a Seurat object that contains the the batch-corrected expression matrix for batches
}
\examples{
# Load the example data data_SMNN
data("data_iSMNN")

# Provide the marker genes for cluster matching
markers <- c("Col1a1", "Pdgfra", "Ptprc", "Pecam1")

# Specify the cluster labels for each marker gene
cluster.info <- c("fibroblast", "fibroblast", "macrophage", "endothelial cells")

# Harmonize cluster labels across batches
library(SMNN)
batch.cluster.labels <- unifiedClusterLabelling(batches = list(data_SMNN$batch1.mat, data_iSMNN$batch2.mat), features.use = markers,
                                                cluster.labels = cluster.info, min.perc = 0.3)
names(batch.cluster.labels[[1]]) <- colnames(data_iSMNN$batch1.mat)
names(batch.cluster.labels[[2]]) <- colnames(data_iSMNN$batch2.mat)

# Construct the input object for batches using Seurat
library(Seurat)
merge <- CreateSeuratObject(counts = cbind(data_iSMNN$batch1.mat, data_iSMNN$batch2.mat), min.cells = 0, min.features = 0)
batch_id <- c(rep("batch1", ncol(data_iSMNN$batch1.mat)), rep("batch2", ncol(data_iSMNN$batch2.mat)))
names(batch_id) <- colnames(merge)
merge <- AddMetaData(object = merge, metadata = batch_id, col.name = "batch_id")
merge.list <- SplitObject(merge, split.by = "batch_id")

merge.list <- lapply(X = merge.list, FUN = function(x) {
  x <- NormalizeData(x)
  x <- FindVariableFeatures(x, selection.method = "vst", nfeatures = 2000)
})

# Correct batch effect
corrected.results <- iSMNN(object.list = merge.list, batch.cluster.labels = batch.cluster.labels,
                           matched.clusters = c("endothelial cells", "macrophage", "fibroblast"),
                           strategy = "Short.run", iterations = 5, dims = 1:20, npcs = 30, k.filter = 30)

}
\references{
Yuchen Yang, Gang Li, Li Qian, Yun Li. iSMNN 2020
}
\author{
Yuchen Yang <yyuchen@email.unc.edu>, Gang Li <franklee@live.unc.edu>, Li Qian <li_qian@med.unc.edu>, Yun Li <yunli@med.unc.edu>
}
